[{"categories":null,"content":"DispathcerServlet Spring Web 简易框架 准备 applicationContext.xml 对应 bean \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003cbeans\u003e \u003cbean id=\"fruitDao\" class=\"com.test.dao.FruitDao\"/\u003e \u003cbean id=\"fruitService\" class=\"com.test.service.impl.FruitServiceImpl\"\u003e \u003cproperty name=\"fruitDao\" ref=\"fruitDao\"/\u003e \u003c/bean\u003e \u003cbean id=\"fruit\" class=\"com.test.controller.FruitController\"\u003e \u003cproperty name=\"fruitService\" ref=\"fruitService\"/\u003e \u003c/bean\u003e \u003c/beans\u003e 通过实现 ServletContextListener 监听器接口，并重写 contextInitialized 方法获取 BeanFactory 对象放入 ServletContext 域中 // 创建 BeanFactory 对象 BeanFactory beanFactory = new ClassPathXmlApplicationContext(); ServletContext application = ServletContextEvent.getServletContext(); // 放入应用域总中 application.setAttribute(\"beanFactory\", beanFactory); 新建 BeanFactory 接口，并创建 ClassPathXmlApplicationContext 实现类通过 applicationContext.xml 文件获取相对应的 bean // 转化 path 为流 InputStream is = this.getClass().getClassLoader().getResourceAsStream(path); // 获取 document 对象 DocumentBuildFactory dbf = DocumentBuildFactory.newInstance(); DocumentBuild db = dbf.newDocumentBuild(); Document doc = db.parse(is); 遍历节点找到元素节点加入到 beanMap 中 // 获取 nodeList NodeList nodeList = doc.getDocumentElement(); // 将 bean 节点放入 beanMap for (int i = 0; i \u003c nodeList.getLength(); i++) { Node node = NodeList.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) { Element element = (Element) node; String id = element.getAttribute(\"id\"); String clazz = element.getAttribute(\"class\"); // 反射获取 class Object beanObj = Class.forName(clazz).newInstance(); beanMap.put(id, beanObj); } } 再次循环进行依赖注入 for (int i = 0; i \u003c nodeList.getLength(); i++) { Node node = nodeList.item(i); if (node.getNodeType() == Node.ELEMENT_NODE) { // 获取子节点 property Element baseBean = (Element) node; String baseId = baseBean.getAttribute(\"id\"); NodeList childNodes = node.getChildNodes(); for (int j = 0; j \u003c childNodes.getLength(); j++) { Node property = childNodes.item(j); if (property.getNodeType() == Node.ELEMENT_NODE) { Element propertyEle = (Element) property; String name = propertyEle.getAttribute(\"name\"); String ref = propertyEle.getAttribute(\"ref\"); Object baseObj = beanMap.get(baseId); Object refObj = beanMap.get(ref); // 反射获取成员变量 Field dependency = baseObj.getClass().getDeclaredField(name); dependency.setAccessible(true); // 设置依赖 dependency.set(baseObj, refObj); } } } } 在 DispatcherServlet 类中继承 HttpServlet 并在 init() 方法中从 ServletContext 获取 beanFactory public class DispatcherServlet implements HttpServlet { public BeanFactory beanFactory; @Override public void init () throw ServletException { ServletContext application = this.getServletContext(); Object beanFactoryObj = application.getAttribute(\"beanFactory\"); if (beanFactoryObj != null) { beanFactory = (BeanFactory) beanFactory; }else { throw new RuntimeException(\"Ioc 容器获取失败！\"); } } } 在 DispatcherServlet service 方法中利用请求中的 operate 反射获取调用方法，并通过 url 地址从 beanFactory 获取操作的 Controller public void service (HttpServletRequest request, HttpServletResponse response) throw ServletException, IOException, IllegalAccessException, InvocationTargetException { request.setCharacterEncoding(\"UTF-8\"); // 获取路径并分割 String uri = request.getServletPath().substring(1); // /fruit?operate=add -\u003e fruit?.. String beanName = uri.contains(\"?\") ? uri.substring(0, uri.indexOf(\"?\") : uri); String operate = request.getParameter(\"operate\"); if (operate == null || \"\".equals(operate)) { operate = \"index\"; } // 通过 beanName 获取对应实体类 Object beanObj = Class.forName(beanName).newInstance(); // 获取对应 operate Method[] methods = beanObj.getClass().getDeclaredMethods(); for (Method method : methods) { String methodName = method.getName(); if (operate.equals(methodName)) { // 获取参数 Parameter[] parameter = method.getParameters(); Object[] paramVal = new Object[parameter.length]; for (int i = 0; i \u003c parameters.length; i++) { if (parameters[i].getType().getName().contains(\"request\")) { paramVal[i] = request; } else if (parameters[i].getType().getName().contains(\"response\")) { paramVal[i] = response; } } method.setAccessible(true); met","date":"2022-12-05","objectID":"/dispathcerservlet/:0:0","tags":null,"title":"DispathcerServlet Spring Web 简易框架","uri":"/dispathcerservlet/"},{"categories":null,"content":"JavaWeb 学习笔记 一、Servlet web.xml 中配置 servlet 映射 \u003cservlet\u003e \u003cservlet-name\u003eAddServlet\u003c/servlet-name\u003e \u003cservlet-class\u003ecom.test.servlets.AddServlet\u003c/servlet-class\u003e \u003c/servlet\u003e \u003cservlet-mapping\u003e \u003cservlet-name\u003eAddServlet\u003c/servlet-name\u003e \u003curl-pattern\u003e/add\u003c/url-pattern\u003e \u003c/servlet-mapping\u003e 💡 request → url-pattern → AddServlet → servlet 对应的 servlet-name → 找到 servlet-calss 方法 → doPost() POST 方式下，设置编码，防止中文乱码。GET 方式目前不需要设置编码 （基于 tomcat8） public void doPost (HttpServletRequest request, HttpServletResponse response) { request.setCharacterEncoding(\"UTF-8\"); } // tomcat 7 Get 设置编码 String fname = request.getParameter(\"fname\"); byte[] bytes = fname.getBytes(\"iso-8859-1\"); fname = new String(bytes, \"UTF-8\"); 💡 需要注意的是，设置编码必须放在所有获取参数之前 小结 继承关系：HttpServlet → GenericServlet → Servlet Servlet 中的核心方法：init(), service(), destory() 服务方法： 当有请求过来时，service 方法会自动响应（tomcat 容器调用） 在 HttpServlet 中会分析请求方式，（Get、Post、Put、Delete） 在 HttpServlet 中调用 do 开头方法，这些方法默认都是 405 需要子类继承重写相对应的 doPost、doGet 等方法 Servlet 在容器中是：单例的、线程不安全的 服务器内部转发以及客户端重定向 服务器内部转发： request.getRequestDispatcher(”…”).forward(request, response) 客户端重定向：response.sendRedirect(”…”) ","date":"2022-12-05","objectID":"/javaweb/:0:0","tags":null,"title":"JavaWeb 学习笔记","uri":"/javaweb/"},{"categories":null,"content":"二、Java 获取 Xml 文件里的参数 根据 fruit 找到对应的组件：FruitController，这个对应的依据我们存储在 xx.xml中 // 通过类获取输入流 InputStream is = this.getClass().getClassLoader().getResourceAsStream(\"xx.xml\"); try { // 获取 xml 配置文件 DocumentBuildFactory dbf = DocumentBuildFactory.newInstance(); DocumentBuild db = dbf.newDocumentBuild(); Document doc = db.parse(is); // 通过 document 获取元素 Element element = doc.getDocumentElement(); // 获取所有 bean 节点 NodeList nodeList = element.getElementsByTagName(\"bean\"); for (int i = 0; i \u003c nodeList.getLength(); i++) { // 获取每一个 bean Node bean = nodeList.item(i); /* 节点类型是元素节点 Xml 有元素节点和文本节点 \u003cbean\u003ehello\u003c/bean\u003e \u003cbean\u003e为元素节点，hello 为文本节点 */ if (bean.getNodeType == Node.ELEMENT_NODE) { // 强制转 element 并获取 id and class Element ele = (Element) bean; String id = ele.getAttribute(\"id\"); String clazz = ele.getAttribute(\"class\"); // 获取 bean 类，FruitController、UserController Object beanObj = Class.forName(clazz).newInstance(); } } } ","date":"2022-12-05","objectID":"/javaweb/:1:0","tags":null,"title":"JavaWeb 学习笔记","uri":"/javaweb/"},{"categories":null,"content":"三、Servlet 生命周期中的方法 初始化方法：init()、init(config) public void init(ServletConfig config) throws ServletException { this.config = config; init(); } 因此，如果我们需要在初始化执行一些自定义操作，可以重写无参 init() 我们可以通过 getConfig() 获取 ServletConfig 对象 通过 config.getInitParameter() 获取初始化参数 - web.xml 里的 通过 ServletContext 获取配置的上下文参数 ","date":"2022-12-05","objectID":"/javaweb/:2:0","tags":null,"title":"JavaWeb 学习笔记","uri":"/javaweb/"},{"categories":null,"content":"DispatcherServlet 和 Ioc 整合，Spring 框架底层原理 简易版 String 框架实现 ","date":"2022-12-05","objectID":"/javaweb/:2:1","tags":null,"title":"JavaWeb 学习笔记","uri":"/javaweb/"},{"categories":null,"content":"四、Filter Filter 也属于 Servlet 规范 Filter 开发步骤：新建类实现 Filter 接口，然后实现其中的三个方法：init、doFilter、destory 配置 Filter，可以用注解@WebFilter，也可以使用 xml 文件 过滤器链 FilterChain 如果采取的是注解方式配置，那么过滤器的拦截顺序是按照全类名的先后顺序排序的 如果采取的是 xml 方式配置，那么按照配置的先后顺序进行排序 ","date":"2022-12-05","objectID":"/javaweb/:3:0","tags":null,"title":"JavaWeb 学习笔记","uri":"/javaweb/"},{"categories":null,"content":"五、ThreadLocal ThreadLocal 称之为本地线程 我们可以通过 set() 方法在当前线程上存储数据，通过 get() 方法在当前线程上获取数据 ","date":"2022-12-05","objectID":"/javaweb/:4:0","tags":null,"title":"JavaWeb 学习笔记","uri":"/javaweb/"},{"categories":null,"content":"六、Listener ServletContextListener - 监听 ServletContext 对象的创建和销毁的过程 HttpSessionListener - 监听 HttpSession 对象的创建和销毁的过程 ServletRequestListener - 监听 ServletRequest 对象的创建和销毁的过程 ServletContextAttributeListener - 监听 ServletContext 的保存作用域改动 (add、remove、replace) HttpSessionAttributeListener - 监听 HttpSession 的保存作用域改动 (add、remove、replace) ServletRequestAttributeListener - 监听 ServletRequest 的保存作用域改动 (add、remove、replace) HttpSessionBindingListener - 监听某个对象在 Session 域中的创建与移除 HttpSessionActivationListener - 监听某个对象在 Session 域中的序列化和反序列化 ","date":"2022-12-05","objectID":"/javaweb/:5:0","tags":null,"title":"JavaWeb 学习笔记","uri":"/javaweb/"},{"categories":null,"content":"Hugo 博客搭建 + 使用 Github Page 部署作为站点并用 Github Action 自动部署站点 ","date":"2022-10-09","objectID":"/how-to-build-hugo/:0:0","tags":null,"title":"Hugo 博客搭建 + 使用 Github 部署作为自己的站点","uri":"/how-to-build-hugo/"},{"categories":null,"content":"一、概述 作为一名程序员，需要有自己的博客记录一些学习笔记，所以记录自己搭建博客的过程，以供参考。 博客框架选择使用 Go 编写的 Hugo ，它在 Github 上的 Star 63k ，部署在 Github Page ，搭配 Github Action 实现自动化发布博客。 搭建环境: 操作系统: Ubuntu 18.04 博客框架: Hugo 博客主题: LoveIt 工具: Git ","date":"2022-10-09","objectID":"/how-to-build-hugo/:1:0","tags":null,"title":"Hugo 博客搭建 + 使用 Github 部署作为自己的站点","uri":"/how-to-build-hugo/"},{"categories":null,"content":"二、博客搭建 ","date":"2022-10-09","objectID":"/how-to-build-hugo/:2:0","tags":null,"title":"Hugo 博客搭建 + 使用 Github 部署作为自己的站点","uri":"/how-to-build-hugo/"},{"categories":null,"content":"（一）Hugo 框架下载 1、首先进入到 Hugo Github 下载 Releases 最新版本，我用的是 v0.104.3。 我下载的是 hugo_0.104.3_linux-amd64.tar.gz，Intel 使用 amd 安装包，AMD 选择 arm 安装包，window 用户选择对应 window 安装包即可，不确定自己的 cpu 架构可以在 Linux 系统下输入 uname -m 查看。关于 amd 与 arm 更多知识请看____。（埋坑） 2、下载完成后，解压缩包。 mkdir hugo tar -zxvf hugo_0.104.3_linux-amd64.tar.gz -C hugo 如果是下载 tar.gz 那么需要手动配置 Linux 环境变量，$PATH: 后面跟你 hugo 目录的绝对路径。 echo \"export PATH=$PATH:/home/jaks/hugo\" \u003e\u003e ~/.bashrc 3、输入 hugo version 打印出版本信息即安装成功。 ","date":"2022-10-09","objectID":"/how-to-build-hugo/:2:1","tags":null,"title":"Hugo 博客搭建 + 使用 Github 部署作为自己的站点","uri":"/how-to-build-hugo/"},{"categories":null,"content":"（二）Hugo 框架配置 1、在 Linux home 目录下使用 hugo 命令创建一个新的站点。 hugo new site hugo-site 之后添加博客主题，这里我选用的是 LoveIt 主题，更多精美主题可前往 主题 查看。 2、进入你的 hugo-site 目录，使用 Git 初始化目录，然后从 Github 下载主题到站点的 themes 目录。 cd hugo-site git init git submodule add https://github.com/dillonzq/LoveIt.git themes/LoveIt 3、配置文件替换，进入下载的主题找到 exampleSite 目录下的 config.toml 文件复制到 hugo-site 目录。 ","date":"2022-10-09","objectID":"/how-to-build-hugo/:2:2","tags":null,"title":"Hugo 博客搭建 + 使用 Github 部署作为自己的站点","uri":"/how-to-build-hugo/"},{"categories":null,"content":"（三）添加一些内容 1、使用 hugo 自带命令创建一个带有固定格式的 .md 文件到 content 目录。 hugo new posts/my-first-post.md 2、使用 vim 打开 my-first-post.md 会看到 draft: true。 草稿不会被部署，一旦完成文章，更新草稿头部的 draft: false 即可在发布博客时显示文章。 ","date":"2022-10-09","objectID":"/how-to-build-hugo/:2:3","tags":null,"title":"Hugo 博客搭建 + 使用 Github 部署作为自己的站点","uri":"/how-to-build-hugo/"},{"categories":null,"content":"（四）启动 hugo 服务 1、现在可以启动 hugo 博客查看了！ hugo server -D | EN +------------------+----+ Pages | 10 Paginator pages | 0 Non-page files | 0 Static files | 3 Processed images | 0 Aliases | 1 Sitemaps | 1 Cleaned | 0 Total in 11 ms Watching for changes in /Users/bep/quickstart/{content,data,layouts,static,themes} Watching for config changes in /Users/bep/quickstart/config.toml Environment: \"development\" Serving pages from memory Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) Press Ctrl+C to stop 博客地址为 http://localhost:1313 在编辑或者添加新的博客文件时只需要刷新页面即可看到更新。（有时你需要 Ctrl + R 强刷浏览器）。 ","date":"2022-10-09","objectID":"/how-to-build-hugo/:2:4","tags":null,"title":"Hugo 博客搭建 + 使用 Github 部署作为自己的站点","uri":"/how-to-build-hugo/"},{"categories":null,"content":"三、使用 Github 作为博客站点 到这一步你已经成功完成了 hugo 博客的搭建，现在需要通过域名发布博客让更多的人看到，我选择使用 Github Page 进行博客站点的发布，无需任何费用。 ","date":"2022-10-09","objectID":"/how-to-build-hugo/:3:0","tags":null,"title":"Hugo 博客搭建 + 使用 Github 部署作为自己的站点","uri":"/how-to-build-hugo/"},{"categories":null,"content":"（一）配置 Github SSH key 1、通过配置 ssh 即可无需输入 账号密码安全访问 repo，进入到 Linux home 目录。输入如下命令生成 ssh key。 2、首先配置如下命令，如有配置可跳过。 git config --global user.name 'xxx' git config --global user.email 'xxx@xx.xxx' 3、生成密钥。 ssh-keygen -t rsa -C '上面的邮箱' 代码参数的含义 -t 指定密钥类型，默认是 rsa，可以省略 -C 设置注释文字，比如邮箱 -f 指定密钥文件的存储文件名 4、按回车后进入 .ssh 获取公钥，id_rsa 是私钥，id_rsa.pub 是公钥。 cd ./.ssh vim id_rsa.pub 5、复制 id_rsa.pub 公钥，进入 Github 设置远程登陆。点击右上角头像 → Setting 。 6、会看到左边这些目录，选择 SSH and GPG keys。 7、创建 New SSH key，粘贴你的公钥到 key 中，Title 可以随意设置，Key type 默认第一个即可。使用下面的命令测试以下配置是否成功。 ssh -T git@github.com 8、看到以下信息 Github SSH key 就配置成功了。 ","date":"2022-10-09","objectID":"/how-to-build-hugo/:3:1","tags":null,"title":"Hugo 博客搭建 + 使用 Github 部署作为自己的站点","uri":"/how-to-build-hugo/"},{"categories":null,"content":"（二）创建 Github Page 页面 1、首先，登录到 Github，右上角头像选择 Your repositories 2、选择 New 3、在 Repository name 一栏填写你的 Github 名称 + github.io，eg: sihe-gg.github.io。我已经创建过了，所以填写了 yourname.github.io，把 yourname 换成你的 github 名称。 ","date":"2022-10-09","objectID":"/how-to-build-hugo/:3:2","tags":null,"title":"Hugo 博客搭建 + 使用 Github 部署作为自己的站点","uri":"/how-to-build-hugo/"},{"categories":null,"content":"（三）部署博客到 Github Page 1、创建完成你的 Github Page 之后，进入到 Linux 命令行，到 hugo-site 目录下输入如下命令生成你的博客页面，同时也会将 ./content 下草稿为 false（draft: false） 的文章发布。 hugo Start building sites … hugo v0.104.3-58b824581360148f2d91f5cc83f69bd22c1aa331 linux/amd64 BuildDate=2022-10-04T14:25:23Z VendorInfo=gohugoio | EN | ZH-CN -------------------+-----+-------- Pages | 7 | 10 Paginator pages | 0 | 0 Non-page files | 0 | 0 Static files | 108 | 108 Processed images | 0 | 0 Aliases | 1 | 2 Sitemaps | 2 | 1 Cleaned | 0 | 0 Total in 599 ms 2、进入到 ./public 可以看到 hugo 自动生成的博客框架，我们需要做的是把 ./public 目录下的所有文件上传到 yourname.github.io 中。进入到 ./public 输入如下命令。 # 初始化 git 仓库 git init # 指定远程仓库 git remote add origin git@github.com:yourname/yourname.github.io.git # 添加所有文件 git add . # 提交 git commit -m '博客页面' # 推送至 Github git push --set-upstream origin master 3、大功告成了，输入网址 http://yourname.github.io ，现在快去看看你的博客吧，let`s go！ 但是！当我们写完博客文章后，还需要输入 hugo 生成网站，手动切换到 ./public 目录上传，操作比较繁琐，这时我们可以使用 Github Action 自动化操作部署。 ","date":"2022-10-09","objectID":"/how-to-build-hugo/:3:3","tags":null,"title":"Hugo 博客搭建 + 使用 Github 部署作为自己的站点","uri":"/how-to-build-hugo/"},{"categories":null,"content":"四、使用 Github Action 自动部署博客 Github Action 是一个持续集成和持续交付（CI/CD）平台，可用于自动执行构建、测试和部署管道，目前已经有很多开发好的工作流，可以通过简单的配置即可直接使用。 1、再创建一个仓库名为 myBlog，并设为私有 Private 2、现在应该上传我们的 hugo-site 目录到 myBlog 仓库，进入 Linux 界面，找到并进入你的 hugo-site 目录，由于刚才已经使用 git init 命令初始化过该目录，依次使用如下命令上传至 Github 仓库。 # 指定远程仓库 git remote add origin git@github.com:yourname/myBlog.git # 添加所有文件 git add . # 提交 git commit -m '博客代码' # 推送至 Github git push --set-upstream origin master 3、推送完成后，在 blog-site 目录下新建目录 .github，创建一个自动化发布博客的 .yml 配置文件。 mkdir .github/workflows cd ./.github/workflows vim myAction.yml 4、在 myAction.yml 配置文件中填写如下信息。 name: github pages # on 是 Actions 的触发条件，这里的配置说明当 master 分支有提交的时候，根据这个配置文件执行 on: push: branches: - main # Set a branch to deploy # jobs 是要执行的任务，我们看到他要执行 deploy jobs: deploy: runs-on: ubuntu-18.04 # 运行环境 steps: # 执行步骤 # checkout 分支 - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod # 安装 hugo - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: 'latest' # extended: true # 编译站点 - name: Build run: hugo # 创建 CNAME，这个是原始配置中没有的 #- uses: \"finnp/create-file-action@master\" # env: # FILE_NAME: \"./public/CNAME\" # FILE_DATA: \"h1z3y3.me\" # 将站点发布到对应分支 - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: yourname/yourname.github.io PUBLISH_BRANCH: main publish_dir: ./public 5、在配置文件中需要修改的是 on: push: branches: - main # 这里修改为 myBlog 的主分支名称 如上图，我的 branches 需要修改为 main → master。 jobs: deploy: - name: Deploy EXTERNAL_REPOSITORY: 填写刚才创建的 Github Page 库地址 PUBLISH_BRANCH： 如上图查看主分支名称填写 6、还差一步，申请 Github token 进入 Github，右上角头像 → setting 左边菜单栏选择最底部 Developer settings → Personal access tokens 选择 Generate new token，再次输入密码后，进入页面，注意：需要在 Select scopes 中勾选 repo 和 workflow，Expiration 过期日期写的长一点。 点击 Generate token，复制新生成的 token，注意：只显示一次，不要弄丢。 进入 myBlog 页面，点击 Settings 选择 Secrets → Actions → New repository secret Name 填写 PERSONAL_TOKEN，Secret 填写刚刚申请的 token 7、最后，只需要用如下 git 命令上传到 myBlog 库中，每次写完博客文章 git push 推送完成后就可以自动执行 hugo 命令，生成在 public 目录下的所有文件上传至你的 Github Page，自动化生成你的博客网页。 git add . git commit -m 'upload action config' git push 至此，我们的 Hugo 博客就搭建完成了，每当我们通过 Markdown 语法完成博客内容编辑后，只需要推送至私人仓库，等待几分钟， Github Action 就会自动化发布你的博客，再通过 Github Page 上你的域名去访问更新后的博客。 ","date":"2022-10-09","objectID":"/how-to-build-hugo/:4:0","tags":null,"title":"Hugo 博客搭建 + 使用 Github 部署作为自己的站点","uri":"/how-to-build-hugo/"}]